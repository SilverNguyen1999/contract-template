// SPDX-License-Identifier: UNLICENSED
pragma solidity ^0.8.0;

import "../refs/IERC721State.sol";
import "./refs/ERC721NonceUpgradeable.sol";
import "./ERC721PresetMinterPauserAutoIdCustomizedUpgradeable.sol";

abstract contract ERC721CommonUpgradeable is
  ERC721NonceUpgradeable,
  ERC721PresetMinterPauserAutoIdCustomizedUpgradeable,
  IERC721State
{
  error ErrInvalidArrayLength();
  error ErrNonExistentToken();

  constructor() {
    _disableInitializers();
  }

  /**
   * @inheritdoc IERC721State
   */
  function stateOf(uint256 _tokenId) external view virtual override returns (bytes memory) {
    if (!_exists(_tokenId)) revert ErrNonExistentToken();
    return abi.encodePacked(ownerOf(_tokenId), nonces[_tokenId], _tokenId);
  }

  /**
   * @dev Override `ERC721Upgradeable-_baseURI`.
   */
  function _baseURI()
    internal
    view
    virtual
    override(ERC721Upgradeable, ERC721PresetMinterPauserAutoIdCustomizedUpgradeable)
    returns (string memory)
  {
    return super._baseURI();
  }

  /**
   * @dev Override `IERC165-supportsInterface`.
   */
  function supportsInterface(bytes4 interfaceId)
    public
    view
    virtual
    override(ERC721Upgradeable, ERC721PresetMinterPauserAutoIdCustomizedUpgradeable)
    returns (bool)
  {
    return super.supportsInterface(interfaceId);
  }

  /**
   * @dev Override `ERC721PresetMinterPauserAutoIdCustomizedUpgradeable-_beforeTokenTransfer`.
   */
  function _beforeTokenTransfer(address _from, address _to, uint256 _firstTokenId, uint256 _batchSize)
    internal
    virtual
    override(ERC721NonceUpgradeable, ERC721PresetMinterPauserAutoIdCustomizedUpgradeable)
  {
    super._beforeTokenTransfer(_from, _to, _firstTokenId, _batchSize);
  }

  /**
   * @dev Bulk create new tokens for `_recipients`. Tokens ID will be automatically
   * assigned (and available on the emitted {IERC721Upgradeable-Transfer} event), and the token
   * URI autogenerated based on the base URI passed at construction.
   *
   * See {ERC721Upgradeable-_mint}.
   *
   * Requirements:
   *
   * - the caller must have the `MINTER_ROLE`.
   */
  function bulkMint(address[] calldata _recipients)
    external
    virtual
    onlyRole(MINTER_ROLE)
    returns (uint256[] memory _tokenIds)
  {
    if (_recipients.length == 0) revert ErrInvalidArrayLength();
    _tokenIds = new uint256[](_recipients.length);

    for (uint256 _i = 0; _i < _recipients.length; _i++) {
      _tokenIds[_i] = _mintFor(_recipients[_i]);
    }
  }
}
